package net.sf.aislib.tools.mapping.library.generators;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import net.sf.aislib.tools.mapping.library.Generator;
import net.sf.aislib.tools.mapping.library.structure.Field;
import net.sf.aislib.tools.mapping.library.structure.JavaClass;
import net.sf.aislib.tools.mapping.library.structure.JavaField;
import net.sf.aislib.tools.mapping.library.structure.Structure;


/**
 * <code>BaseX.java</code> generator.
 *
 * @author Milosz Tylenda, AIS.PL
 */
public class BeanGenerator extends Generator {

  /** Mapping: short name to full class name. */
  private static final Map LONG_CLASS_NAMES = new HashMap(4);
  private static final String HIDDEN_TO_STRING_VALUE = "\"-- HIDDEN --\"";

  static {
    LONG_CLASS_NAMES.put("BigDecimal", "java.math.BigDecimal");
    LONG_CLASS_NAMES.put("Timestamp", "java.sql.Timestamp");
    LONG_CLASS_NAMES.put("Array", "java.sql.Array");
    LONG_CLASS_NAMES.put("Blob", "java.sql.Blob");
  }

  /** List containing Field objects from Structure. */
  private List fieldList;

  /** Buffer to store content of a generated file. */
  private StringBuffer fileContent;

  /** Whether to generate support for PropertyChange? */
  private boolean propertyChangeSupport;

  private File initDirectory(File destinationDir) throws IOException {
    File objectsDir = new File(destinationDir.getPath() + File.separator + objectsSubdir);
    if (!objectsDir.exists()) {
      objectsDir.mkdirs();
    }
    File baseDir = new File(objectsDir.getPath() + File.separator + "base");
    if (!baseDir.exists()) {
      baseDir.mkdirs();
    }
    return baseDir;
  }

  private Writer initWriter(String className, File baseDir) throws IOException {
    return new FileWriter(baseDir.getPath() + File.separator + "Base" + className + ".java");
  }

  public void generate() throws IOException {
    File baseDir = initDirectory(destinationDir);
    List structureList = database.getStructureList();
    for (int i = 0, size = structureList.size() ; i < size ; i++) {  // all structures
      Structure structure = (Structure) structureList.get(i);

      fileContent    = new StringBuffer(4096);
      fieldList      = structure.getFields().getFieldList();
      Collections.sort(fieldList); // For better Javadoc.
      propertyChangeSupport = structure.getJavaClass().isPropertyChangeSupport();

      JavaClass javaClass = structure.getJavaClass();
      putPackage();
      putImports();
      putClassJavadoc(structure);
      putClassBegin(javaClass);
      putProperties();
      putGetSet();
      putPropertyChangeCode();
      putToString(structure);
      putClassEnd();

      Writer writer = initWriter(javaClass.getName(), baseDir);    // open file
      writer.write(fileContent.toString());
      writer.close();
    }
    log(structureList.size() + " BaseX class(es) generated");
  }

  private void putPackage() {
    write("package " + packageName + "." + objectsSubpackage + ".base;\n\n"); // Use superclass' properties.
  }

  private void putImports() {
    Set usedClasses = new TreeSet();
    usedClasses.add("java.io.Serializable");
    if (propertyChangeSupport) {
      usedClasses.add("java.beans.PropertyChangeSupport");
      usedClasses.add("java.beans.PropertyChangeListener");
    }

    for (int i = 0, size = fieldList.size() ; i < size ; i++) {
      Field field         = (Field) fieldList.get(i);
      JavaField javaField = field.getJavaField();
      String type         = javaField.getType();
      String longName     = (String) LONG_CLASS_NAMES.get(type);
      if (longName != null) {
        usedClasses.add(longName);
      }
    }

    for (Iterator iter = usedClasses.iterator() ; iter.hasNext() ; ) {
      String longName = (String) iter.next();
      write("import " + longName + ";\n");
    }
    write("\n");
  }

  private void putClassJavadoc(Structure structure) {
    String className = structure.getJavaClass().getName();
    String pcSupport = "";
    if (propertyChangeSupport) {
      pcSupport =", with PropertyChange support";
    }
    write("/**\n");
    write(" * Counterpart of <code>" + structure.getName()  + "</code> structure" + pcSupport + ".\n");
    write(" * This class was generated by BeanGenerator.<br><br>\n");
    write(" * <table border=\"1\">\n");
    write(" * <caption>Base" + className + " fields</caption>\n");
    write(" * <tr>\n");
    write(" * <th>Java name</th><th>Java type</th>");
    write("<th>Java default</th><th>Structure field name</th><th>SQL column</th>\n");
    write(" * </tr>\n");
    for (int i = 0, size = fieldList.size() ; i < size ; i++) {
      Field field         = (Field) fieldList.get(i);
      if (field.isPrimaryKey()) {  // mark primary keys by a green background
        write(" * <tr bgcolor=\"#00FF00\">\n");
      } else {
        write(" * <tr>\n");
      }
      write(" * <td>" + field.getJavaField().getName() + "</td>\n");
      write(" * <td><code>" + field.getJavaField().getType() + "</code></td>\n");
      write(" * <td>" + field.getJavaField().getDefault() + "&nbsp;</td>\n");
      write(" * <td>" + field.getName() + "</td>\n");
      write(" * <td>" + field.getSqlField().getName() + "</td>\n");
      write(" * </tr>\n");
    }
    write(" * </table>\n");
    write(" * @author BeanGenerator\n");
    write(" */\n");
  }

  private void putClassBegin(JavaClass javaClass) {
    write("public abstract class Base" + javaClass.getName() + " implements Serializable {\n\n");
  }

  private void putProperties() {
    for (int i = 0, size = fieldList.size() ; i < size ; i++) {
      Field field         = (Field) fieldList.get(i);
      JavaField javaField = field.getJavaField();
      String type         = javaField.getType();
      String name         = javaField.getName();
      String defaultt     = javaField.getDefault();
      write("  private " + type + " " + name);
      if (defaultt.length() > 0) {            // Handle default value.
        write(" = ");
        if (type.equals("String")) {          // Deal with String.
          write("\"" + defaultt + "\"");
        } else if (type.equals("BigDecimal")) {      // Deal with BigDecimal.
          write("new " + type + "(\"" + defaultt + "\")");
        } else {
          write("new " + type + "(" + defaultt + ")"); // Deal with others.
        }
      }
      write(";\n");
    }
    write("\n");
  }

  private void putGetSet() {
    for (int i = 0, size = fieldList.size() ; i < size ; i++) {
      Field field         = (Field) fieldList.get(i);
      JavaField javaField = field.getJavaField();
      String type         = javaField.getType();
      String name         = javaField.getName();
      String fieldName    = field.getName();
      write("  /**\n");
      write("   * Gets the value of <code>" + fieldName + "</code> field.\n");
      write("   * @return the value of <code>" + fieldName + "</code> field\n");
      write("   */\n");
      write("  public " + type + " " + Utils.getter(name) + " {\n");
      write("    return " + name + ";\n");
      write("  }\n\n");
      write("  /**\n");
      write("   * Sets the " + type + " value of <code>" + fieldName + "</code> field.\n");
      write("   * @param _" + name + " the new value for <code>" + fieldName + "</code> field\n");
      write("   */\n");
      write("  public void set" + Utils.capitalize(name) + "(" + type + " _" + name + ") {\n");
      if (propertyChangeSupport) {
        write("    if (pcs != null) {\n");
        write("      pcs.firePropertyChange(\"" + name + "\", " + name + ", _" + name + ");\n");
        write("    }\n");
      }
      write("    " + name + " = _" + name + ";\n");
      write("  }\n\n");
    }
  }

  private void putToString(Structure structure) {
    int fieldsSize = fieldList.size();
    write("  /**\n");
    write("   * Returns property names and values contained in this object.\n");
    write("   * @return Property names and values contained in this object\n");
    write("   */\n");
    write("  public String toString() {\n");
    write("    return \"" + structure.getName() + "\"");

    if (fieldsSize > 0) {
      write(" + \": \"");
    }

    for (int i = 0 ; i < fieldsSize ; i++) {
      Field field         = (Field) fieldList.get(i);
      JavaField javaField = field.getJavaField();
      String name         = javaField.getName();
      String fieldName    = field.getName();
      write(" +\n");
      write("      \"" + fieldName + ": \" + " + (javaField.isToString() ? name : HIDDEN_TO_STRING_VALUE));
      if (i < (fieldsSize - 1)) {
        write(" + \", \"");
      }
    }
    write(";\n");
    write("  }\n\n");
  }

  private void putPropertyChangeCode() {
    if (!propertyChangeSupport) {
      return;
    }
    write("  private PropertyChangeSupport pcs;\n\n");
    write("  /**\n");
    write("   * Adds a PropertyChangeListener to the listener list. The listener is registered for all properties.\n");
    write("   * @param listener the PropertyChangeListener to be added\n");
    write("   */\n");
    write("  public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n");
    write("    if (pcs == null) {\n");
    write("      pcs = new PropertyChangeSupport(this);\n");
    write("    }\n");
    write("    pcs.addPropertyChangeListener(listener);\n");
    write("  }\n\n");
    write("  /**\n");
    write("   * Adds a PropertyChangeListener for a specific property.\n");
    write("   * The listener will be invoked only when that specific property changes its value.\n");
    write("   * @param propertyName the name of the property to listen on\n");
    write("   * @param listener the PropertyChangeListener to be added\n");
    write("   */\n");
    write("  public synchronized void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n");
    write("    if (pcs == null) {\n");
    write("      pcs = new PropertyChangeSupport(this);\n");
    write("    }\n");
    write("    pcs.addPropertyChangeListener(propertyName, listener);\n");
    write("  }\n\n");
    write("  /**\n");
    write("   * Removes a PropertyChangeListener from the listener list.\n");
    write("   * This removes a PropertyChangeListener that was registered for all properties.\n");
    write("   * @param listener the PropertyChangeListener to be removed\n");
    write("   */\n");
    write("  public void removePropertyChangeListener(PropertyChangeListener listener) {\n");
    write("    if (pcs == null) {\n");
    write("      return;\n");
    write("    }\n");
    write("    pcs.removePropertyChangeListener(listener);\n");
    write("  }\n\n");
    write("  /**\n");
    write("   * Removes a PropertyChangeListener for a specific property.\n");
    write("   * @param propertyName the name of the property that was listened on\n");
    write("   * @param listener the PropertyChangeListener to be removed\n");
    write("   */\n");
    write("  public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n");
    write("    if (pcs == null) {\n");
    write("      return;\n");
    write("    }\n");
    write("    pcs.removePropertyChangeListener(propertyName, listener);\n");
    write("  }\n\n");
    write("  /**\n");
    write("   * Checks if there are any listeners for a specific property.\n");
    write("   * @param propertyName the property name\n");
    write("   * @return true if there are one or more listeners for the given property\n");
    write("   */\n");
    write("  public boolean hasListeners(String propertyName) {\n");
    write("    if (pcs == null) {\n");
    write("      return false;\n");
    write("    }\n");
    write("    return pcs.hasListeners(propertyName);\n");
    write("  }\n\n");
    write("  /**\n");
    write("   * Reports a bound property update to any registered listeners.\n");
    write("   * No event is fired if oldValue and newValue are equal and non-null.\n");
    write("   * @param propertyName the programmatic name of the property that was changed\n");
    write("   * @param oldValue the old value of the property\n");
    write("   * @param newValue the new value of the property\n");
    write("   */\n");
    write("  protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {\n");
    write("    if (pcs == null) {\n");
    write("      return;\n");
    write("    }\n");
    write("    pcs.firePropertyChange(propertyName, oldValue, newValue);\n");
    write("  }\n\n");
  }

  private void putClassEnd() {
    write("}\n");
  }

  private void write(String s) {
    fileContent.append(s);
  }

}
